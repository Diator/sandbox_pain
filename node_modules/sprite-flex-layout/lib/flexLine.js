'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CROSS_AXIS_SIZE = (0, _symbol2.default)('crossAxisSize');

var FlexLine = function () {
  function FlexLine(items, container) {
    var _this = this;

    (0, _classCallCheck3.default)(this, FlexLine);

    this.items = items;
    this.container = container;
    this.flexDirection = container.flexDirection;
    this.crossPosition = 0;
    this.crossSpace = 0;
    var props = (0, _util.getProp)(this.flexDirection);
    (0, _keys2.default)(props).forEach(function (prop) {
      _this[prop] = props[prop];
    });
  }

  /**
   * get main axis size base on flex direction
   */


  (0, _createClass3.default)(FlexLine, [{
    key: 'parseAutoCrossMargin',
    value: function parseAutoCrossMargin(item, crossSize) {
      var startAuto = item[this.crossMarginStart] === 'auto';
      var endAuto = item[this.crossMarginEnd] === 'auto';
      if (startAuto || endAuto) {
        if (this.container.alignContent === 'stretch') {
          crossSize += this.crossSpace;
        }
        var layoutSize = item[this.crossLayoutSize];
        var size = 0;
        if (startAuto && endAuto) {
          size = (crossSize - layoutSize) / 2;
        } else if (startAuto) {
          size = crossSize - layoutSize;
        } else {
          size = item[this.crossMarginStart];
        }
        item[this.crossPos] = this.crossPosition + size;
        return true;
      }
      return false;
    }
  }, {
    key: 'parseItemAlignSelf',
    value: function parseItemAlignSelf(item, crossSize) {
      // has auto value in margin on cross axis
      if (this.parseAutoCrossMargin(item, crossSize)) return;

      var alignSelf = item.alignSelf;
      if (alignSelf === 'auto') {
        alignSelf = item.parent.alignItems;
      }
      var flexWrap = this.container.flexWrap;
      if (flexWrap === 'wrap-reverse') {
        alignSelf = (0, _util.exchangeFlexProp)(alignSelf);
      }
      var layoutSize = item[this.crossLayoutSize];
      var itemCrossSize = item[this.crossSize];
      var crossSpace = this.crossSpace;
      if (this.container.alignContent !== 'stretch') {
        crossSpace = 0;
      }
      var crossPosition = 0;
      switch (alignSelf) {
        case 'flex-end':
          crossPosition = crossSpace + crossSize - layoutSize;
          break;
        case 'center':
          crossPosition = (crossSpace + crossSize - layoutSize) / 2;
          break;
        case 'stretch':
          // stretch item cross size
          if (!itemCrossSize) {
            var maxSize = item[this.crossMaxSize] || 0;
            var caculateSize = this.crossAxisSize - item[this.crossLayoutSize] + item[this.crossComputedSize];
            if (this.container.alignContent === 'stretch') {
              caculateSize += this.crossSpace;
            }
            if (maxSize) {
              item[this.crossComputedSize] = Math.min(caculateSize, maxSize);
            } else {
              item[this.crossComputedSize] = caculateSize;
            }
          } else if (flexWrap === 'wrap-reverse') {
            crossPosition = crossSpace + crossSize - layoutSize;
          }
          break;
        case 'baseline':
          throw new Error('align-self:baseline is not support');
        default:
          // default is flex-start
          break;
      }
      var pos = this.crossPosition + crossPosition;
      item[this.crossPos] = pos + (0, _util.parseMarginAuto)(item[this.crossMarginStart]);
    }
  }, {
    key: 'parseAlignSelf',
    value: function parseAlignSelf() {
      var _this2 = this;

      var crossSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this.items.forEach(function (item) {
        _this2.parseItemAlignSelf(item, crossSize);
      });
    }
  }, {
    key: 'hasMarginAutoInMainAxis',
    value: function hasMarginAutoInMainAxis() {
      var _this3 = this;

      return this.items.some(function (item) {
        return item[_this3.mainMarginStart] === 'auto' || item[_this3.mainMarginEnd] === 'auto';
      });
    }
  }, {
    key: 'hasFlexGrow',
    value: function hasFlexGrow() {
      return this.items.some(function (item) {
        return item.flexGrow;
      });
    }
  }, {
    key: 'parseByFlexGrow',
    value: function parseByFlexGrow(space) {
      var _this4 = this;

      var grow = 0;
      var max = 0;
      var items = [];
      this.items.forEach(function (item) {
        grow += item.flexGrow || 0;
        items.push({ max: item[_this4.mainMaxSize], grow: item.flexGrow });
        if (item[_this4.mainMaxSize]) max++;
      });

      var _loop = function _loop() {
        var itemSpace = space / Math.max(grow, 1);
        if (!max) {
          items.forEach(function (item, index) {
            if (item.grow) {
              var increSpace = item.grow * itemSpace;
              _this4.items[index][_this4.mainComputedSize] += increSpace;
              space -= increSpace;
            }
          });
          return 'break';
        }
        var flag = false;
        items.forEach(function (item, index) {
          if (item.max && item.grow) {
            var leaveSpace = item.max - _this4.items[index][_this4.mainComputedSize];
            if (itemSpace * item.grow > leaveSpace) {
              _this4.items[index][_this4.mainComputedSize] = item.max;
              space -= leaveSpace;
              grow -= item.grow;
              delete item.max;
              delete item.grow;
              flag = true;
            }
          }
        });
        if (!grow) return 'break';
        if (!flag) {
          max = 0;
        }
      };

      while (true) {
        var _ret = _loop();

        if (_ret === 'break') break;
      }
      return space;
    }
  }, {
    key: 'parseByMarginAuto',
    value: function parseByMarginAuto(space) {
      var _this5 = this;

      var marginAutoNum = 0;
      this.items.forEach(function (item) {
        if (item[_this5.mainMarginStart] === 'auto') {
          marginAutoNum++;
        }
        if (item[_this5.mainMarginEnd] === 'auto') {
          marginAutoNum++;
        }
      });
      var itemSpace = space / marginAutoNum;
      var pos = 0;
      this.items.forEach(function (item) {
        pos += (0, _util.parseMarginAuto)(item[_this5.mainMarginStart], itemSpace);
        item[_this5.mainPos] = pos;
        pos += item[_this5.mainLayoutSize] - (0, _util.parseMarginAuto)(item[_this5.mainMarginStart]);
        pos += (0, _util.parseMarginAuto)(item[_this5.mainMarginEnd], itemSpace) - (0, _util.parseMarginAuto)(item[_this5.mainMarginEnd]);
      });
    }
  }, {
    key: 'parseJustifyContent',
    value: function parseJustifyContent() {
      var justifyContent = this.container.justifyContent;
      var flexDirection = this.container.flexDirection;
      if (flexDirection === 'row-reverse' || flexDirection === 'column-reverse') {
        justifyContent = (0, _util.exchangeFlexProp)(justifyContent);
      }
      return justifyContent;
    }
  }, {
    key: 'parseByJustifyContentPositive',
    value: function parseByJustifyContentPositive(space) {
      return this.parseByJustifyContentSpace(space);
    }
  }, {
    key: 'parseByJustifyContentSpace',
    value: function parseByJustifyContentSpace(space) {
      var _this6 = this;

      var justifyContent = this.parseJustifyContent();
      var marginSizes = (0, _util.parseSpaceBetween)(space, justifyContent, this.items.length);
      var pos = 0;
      this.items.forEach(function (item, index) {
        pos += marginSizes[index] || 0;
        item[_this6.mainPos] = pos + (0, _util.parseMarginAuto)(item[_this6.mainMarginStart]);
        pos += item[_this6.mainLayoutSize];
      });
    }
  }, {
    key: 'parseByJustifyContentNegative',
    value: function parseByJustifyContentNegative(space) {
      var _this7 = this;

      var shrink = 0;
      var min = 0;
      var items = [];
      this.items.forEach(function (item) {
        var shrinkItem = item.flexShrink * item[_this7.mainComputedSize];
        shrink += shrinkItem;
        items.push({ min: item[_this7.mainMinSize], shrink: shrinkItem });
        if (item[_this7.mainMinSize]) min++;
      });

      var _loop2 = function _loop2() {
        var itemSpace = (0 - space) / shrink;
        if (!min) {
          items.forEach(function (item, index) {
            if (item.shrink) {
              var decreSpace = item.shrink * itemSpace;
              var size = _this7.items[index][_this7.mainComputedSize] - decreSpace;
              if (size > 0) {
                _this7.items[index][_this7.mainComputedSize] -= decreSpace;
                space += decreSpace;
              } else {
                _this7.items[index][_this7.mainComputedSize] = 1;
                space += decreSpace + size;
              }
            }
          });
          return 'break';
        }
        var flag = false;
        items.forEach(function (item, index) {
          if (item.min) {
            var leaveSpace = _this7.items[index][_this7.mainComputedSize] - item.min;
            if (itemSpace * item.shrink > leaveSpace) {
              _this7.items[index][_this7.mainComputedSize] = item.min;
              space += leaveSpace;
              shrink -= item.shrink;
              delete item.min;
              delete item.shrink;
              flag = true;
            }
          }
        });
        if (!flag) {
          min = 0;
        }
      };

      while (true) {
        var _ret2 = _loop2();

        if (_ret2 === 'break') break;
      }
      this.parseByJustifyContentSpace(space);
    }
  }, {
    key: 'parseMainAxis',
    value: function parseMainAxis() {
      var _this8 = this;

      var mainSize = this.container[this.mainSize];
      // container size is not set
      if (!mainSize) {
        var pos = 0;
        this.items.forEach(function (item) {
          item[_this8.mainPos] = pos;
          pos += item[_this8.mainLayoutSize];
        });
        return;
      }
      var space = mainSize - this.mainAxisSize;
      if (space > 0) {
        if (this.hasFlexGrow()) {
          space = this.parseByFlexGrow(space);
        }
        if (this.hasMarginAutoInMainAxis()) {
          return this.parseByMarginAuto(space);
        }
        return this.parseByJustifyContentPositive(space);
      }
      return this.parseByJustifyContentNegative(space);
    }
  }, {
    key: 'mainAxisSize',
    get: function get() {
      var _this9 = this;

      var value = 0;
      this.items.forEach(function (item) {
        value += item[_this9.mainLayoutSize] || 0;
      });
      return value;
    }

    /**
     * get cross axis size based on flex direction
     */

  }, {
    key: 'crossAxisSize',
    get: function get() {
      var _this10 = this;

      if (this[CROSS_AXIS_SIZE]) return this[CROSS_AXIS_SIZE];
      var values = this.items.map(function (item) {
        return item[_this10.crossLayoutSize] || 0;
      });
      var result = Math.max.apply(Math, (0, _toConsumableArray3.default)(values));
      this[CROSS_AXIS_SIZE] = result;
      return result;
    }
  }]);
  return FlexLine;
}();

exports.default = FlexLine;