'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _flexLine = require('./flexLine');

var _flexLine2 = _interopRequireDefault(_flexLine);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Compose = function () {
  function Compose(container) {
    var _this = this;

    (0, _classCallCheck3.default)(this, Compose);

    this.container = container;
    var props = (0, _util.getProp)(container.flexDirection);
    (0, _keys2.default)(props).forEach(function (prop) {
      _this[prop] = props[prop];
    });
    container.children.forEach(function (item) {
      item.config.parse();
    });
    container.children = this.parseOrder(container.children);
    this.flexLines = this.parseFlexLines(container.children);
  }

  (0, _createClass3.default)(Compose, [{
    key: 'parseOrder',
    value: function parseOrder(items) {
      return items.sort(function (a, b) {
        var ar = a.order | 0;
        var br = b.order | 0;
        if (a.order && b.order) return ar > br ? 1 : -1;
        if (a.order) return ar > 0 ? 1 : -1;
        if (b.order) return br > 0 ? -1 : 1;
        return a.id > b.id ? 1 : -1;
      });
    }

    /**
     * parse flex lines by flexWrap
     * @param {Array} items flex items
     */

  }, {
    key: 'parseFlexLines',
    value: function parseFlexLines(items) {
      var _this2 = this;

      var wrap = this.container.flexWrap;
      var flexDirection = this.container.flexDirection;
      var containerPropValue = this.container[this.mainSize];
      var lines = [];
      if (wrap === 'nowrap' || !containerPropValue) {
        lines = [items];
      } else {
        var line = [];
        var propValue = 0;
        items.forEach(function (item) {
          var value = item[_this2.mainLayoutSize];
          if (propValue + value > containerPropValue && line.length) {
            lines.push(line);
            propValue = 0;
            line = [];
          }
          propValue += value;
          line.push(item);
        });
        if (line.length) {
          lines.push(line);
          line = [];
        }
        if (wrap === 'wrap-reverse') {
          lines = lines.reverse();
        }
      }

      if (flexDirection === 'row-reverse' || flexDirection === 'column-reverse') {
        lines = lines.map(function (line) {
          return line.reverse();
        });
      }
      lines = lines.map(function (line) {
        return new _flexLine2.default(line, _this2.container);
      });
      return lines;
    }

    /**
     * parse align-content on multiline flex lines
     */

  }, {
    key: 'parseAlignContent',
    value: function parseAlignContent() {
      var alignContent = this.container.alignContent;
      var crossAxisSize = this.container[this.crossSize];
      var space = 0;
      var lineLength = this.flexLines.length;
      if (crossAxisSize) {
        var linesCrossAxisSize = 0;
        this.flexLines.forEach(function (line) {
          linesCrossAxisSize += line.crossAxisSize;
        });
        // margin between lines
        space = crossAxisSize - linesCrossAxisSize;
      }
      var linesMarginSize = [];
      if (lineLength === 1) {
        this.container.alignContent = 'stretch';
        linesMarginSize = [0, space];
      } else {
        if (this.container.flexWrap === 'wrap-reverse') {
          alignContent = (0, _util.exchangeFlexProp)(alignContent);
        }
        linesMarginSize = (0, _util.parseSpaceBetween)(space, alignContent, lineLength);
      }
      var crossPosition = 0;
      this.flexLines.forEach(function (line, index) {
        crossPosition += linesMarginSize[index] || 0;
        line.crossPosition = crossPosition;
        line.crossSpace = linesMarginSize[index + 1] || 0;
        crossPosition += line.crossAxisSize;
      });
    }
  }, {
    key: 'parseAlignSelf',
    value: function parseAlignSelf() {
      this.flexLines.forEach(function (line) {
        line.parseAlignSelf(line.crossAxisSize);
      });
    }
  }, {
    key: 'computeContainerSize',
    value: function computeContainerSize() {
      var line = this.flexLines[0];
      if (!this.container[this.crossSize]) {
        this.container[this.crossSize] = line.crossAxisSize;
      }
      if (!this.container[this.mainSize]) {
        this.container[this.mainSize] = line.mainAxisSize;
      }
    }
  }, {
    key: 'parseMainAxis',
    value: function parseMainAxis() {
      this.flexLines.forEach(function (line) {
        line.parseMainAxis();
      });
    }
  }, {
    key: 'compose',
    value: function compose() {
      this.parseAlignContent();
      this.parseAlignSelf();
      this.parseMainAxis();
      this.computeContainerSize();
    }
  }]);
  return Compose;
}();

exports.default = Compose;